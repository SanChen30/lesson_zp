# React Hooks

以 use 开头的函数，都是 React 提供的 Hooks 函数，用于在函数组件中使用状态和其他 React 功能。
- react api 最新的语法，文档：https://react.dev/reference/react
- 函数 react 风格比较原生 JS

## react 内置的

- useState

  - 初始化时传入一个纯函数
    如果我想在初始化的时候异步请求数据怎么办？ 用 useEffect 来处理
  - setState 时，也可以传入一个函数，这个函数的参数是上一次的state

- useEffect

effect 副作用

    - 对立面是纯函数
      组件来说输入函数，输出jsx
      useEffect 异步请求数据，并修改状态
    - 请求数据 副作用
    - 第二个参数 依赖项数组
      依赖项数组为空，副作用函数只在挂载时执行一次
      依赖项数组有值，副作用函数会在依赖项变化时执行
      不给依赖项数组，副作用函数会在每次渲染时执行
      return 函数，闭包，在下一次执行effect前调用或组件卸载时调用
    - 三种情况
      - onMounted 挂载时执行
      - onUpdated 更新时执行
      - onUnmounted 卸载时执行


**这个 App.jsx + Demo.jsx 应用主要做了两件事：**
点击一个数字，让它加 1。
当数字是偶数时，显示一个叫 <Demo /> 的组件；奇数时隐藏它。
同时，用定时器每隔 1 秒打印当前数字，并确保不会造成内存泄漏（比如旧的定时器没关掉）。

**主组件 App**
每当 num 发生变化时，这个 useEffect 会先清理上一次的副作用（通过返回的函数），再执行新的副作用。
它启动了一个每秒打印当前 num 的定时器。
返回的函数（return () => {...}）就是清理函数，会在下一次 useEffect 执行前，或者组件卸载时自动调用。
为什么需要清理？
如果不清理，每次 num 变化都会新建一个定时器，但旧的还在跑！
比如：num=0 时开了一个定时器，num=1 时又开一个……最后可能有 10 个定时器同时打印，造成内存泄漏或逻辑混乱。
✅ 所以：只要用了 setInterval、setTimeout、监听事件等，几乎都要写清理函数！

**子组件 Demo**
useEffect(..., [])：只在组件第一次挂载时执行一次（类似 Vue 的 onMounted）。
当 num 变成奇数时，<Demo /> 被移除 → React 自动调用 return () => {...} → 清理定时器。
这样就避免了：组件都消失了，定时器还在后台跑！
✅ 这就是 React 的“生命周期”思想：挂载 → 更新 → 卸载，而 useEffect + 清理函数 能覆盖全部阶段。


## 自定义的