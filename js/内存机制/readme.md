# JS 内存机制

1. JS 执行机制

- 调用栈
- 执行上下文对象
- 变量环境、词法环境、outer（构建词法作用域链、闭包 closure）、this、可执行代码

2. JS 内存

- 栈内存 简单数据类型
- 堆内存 复杂数据类型

3. JS是什么语言? 动态弱类型语言

- 静态语言

使用之前需要确认变量的数据类型

- 动态语言

运行过程中检查数据类型的语言

- 强类型

不可以设置其他类型

- 弱类型

各种类型都可以转换

4. JS 要直接操作内存吗？

不需要

c, c++ malloc 申请内存 free 释放内存

JS 不用直接操作内存

5. Object 类型

key: value 键值对

key的类型：string|number|symbol
value的类型：任意类型

- 八种数据类型
- 简单数据类型和复杂数据类型
  两种机制就搞定了

## 内存空间

1. 代码空间

把代码从硬盘读取到内存中

2. 栈内存

调用栈（JS 执行的主角）

执行快，好管理，大小固定

调用栈的栈顶切换要快，小，连续，切换很频繁

3. 堆内存

打辅助

大对象的空间，分配更耗时

对象是动态的，不连续的


JavaScript V8引擎需要用栈来维护程序执行期间上下文的状态。

如果栈空间太大了，不连续的（对象复杂数据类型也放在栈中），那么会影响上下文切换的效率

进而影响整个程序的执行效率

执行上下文的切换，其实是执行栈栈顶指针的偏移

栈空间，用来存放原始数据类型，空间占据不太且连续

堆空间很大，能存放很多大的数据，不过缺点是分配内促和回收内存都会占用一定的时间。


- 简答数据类型直接使用
- 复杂数据类型，引用地址存放在栈中，实际对象存放在堆中

回收的时候，栈回收（指针偏移） 堆内存中的对象没有变量引用，慢慢回收。

## 内存机制理解闭包

1. 执行流程

- foo函数执行前，先编译 foo 函数，创建一个空的执行上下文（全局执行上下文）

编译过程， setName, getName 快速的词法扫描

闭包内部函数，myName，test1 是由内部函数引用的自由变量，JS会判断有闭包了，堆空间中会创建一个closure(foo)

- getName, setName 执行可以访问到 closure(foo) 中的变量


闭包的核心

第一步 需要扫描内部函数，判断是否有自由变量，有就会在堆内存开辟一个空间 closure(foo)，引用地址会被放到栈内存的执行上下文对象中

第二步 自由变量会被放到堆内存的 closure(foo) 中

