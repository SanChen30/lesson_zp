# 作用域

## JS 执行机制

- v8引擎，编译阶段、执行阶段

- 变量提升 hoisting

正是由于JS存在变量提升特性，从而导致很多与直觉不符的代码，是JS的一个设计缺陷

怎么解决？

- let const 

支持块级作用域

es6 新增的 let const 是为了解决变量提升而来的，但仍要向下兼容

## 一国两制

1. let/const 放到词法环境中，词法环境中存在暂时性死区

2. var 放到变量环境中

3. 为什么变量提升是缺陷。但还要这样设计？

## 作用域

作用域是变量查找的规则

作用域链是变量的查找路径

作用域指在程序中定义变量的区域，该位置决定了变量的可见性、生命周期

作用域控制着变量和函数的可见性和生命周期


作用域的分类：

1. 全局作用域

在任何地方都能访问，其生命周期就是页面周期

2. 函数作用域

只能在函数内部访问，其生命周期就是函数执行周期

3. 块级作用域

let const 新增的作用域，只能在块级内部访问，其生命周期就是块级执行周期

es5 不支持块级作用域

es6 支持块级作用域

- es5 变量提升不合理，不支持块级作用域，二者之间有关系
- JavaScript 当时是一个KPI项目，没想到会火起来，设计周期很短，为了浏览器商业竞争
- JS 当初设计的时候就是为了给页面加动态效果。

规避了：

- 面向对象，是最重要的软件思想，设计起来比较复杂（class，constructor，super，extends，public，private，protected）


- 首字母大写的函数(constructor)+ prototype
- 其他的语言都要支持块级作用域，不能变量提升，而es5 不用支持，为了简单设计
- 没有了块级作用域，再把作用域内部的变量统一提升到作用域的顶部（执行上下文中的作用域），是最快、最简单的设计

## 变量提升带来的问题

1. 变量容易在不被察觉的情况下被覆盖掉，

2. 作用域会先使用函数执行上下文里面的变量

3. 本应该销毁的变量没有被销毁，比如循环变量 i


## JS 如何在现在让变量提升和块级作用域共存？

1. 站在执行上下文的角度，var 放在变量环境，let const 放在词法环境

2. 第一步编译并创建执行上下文，变量环境和词法环境都创建好，变量环境先提升 var 变量，词法环境先提升 let const 变量

- 变量环境
  - 变量提升
- 词法环境
  - 暂时性死区
  - 块级作用域

- 继续执行到块级作用域

- 块级作用域中通过let/const 声明的变量，会被放在词法环境中的一个单独的区域中
- 在词法环境内部，维护了一个小型栈结构
- 块级作用域执行时，首先会查找块级作用域里面的变量
- 词法环境中找变量，在栈顶查找
- 块级作用域执行完后，要出栈，可以确保外界不可访问

## es6 是如何支持块级作用域的？

从执行上下文的角度分析，是栈结构的词法环境，可以单独一个区域放块级作用域中let const 声明的变量

