# AI 全栈项目

## 技能点

### react 开发全家桶
- react + typescript (js超级)
- react-router-dom (前端路由)
- zustand (全局状态管理)
- axios (http 请求库)

### 后端
- nodejs
- nestjs 企业级别后端开发框架
- psql 数据库
- redis 缓存数据库

### AI
- langchain
- coze/n8n
- LLM
- trae/cursor

## 项目安排
- frontend
- backend
- ai_server
- admin 后台管理系统

## git 操作
- 全新的实战项目
  git init
- 提交的时机
  每次完成一个相对独立的模块后，提交一下
  提交信息要准确完整

## react 全家桶

### react-router-dom 
- 前端路由
- **pnpm i react-router-dom**

1. 早期的前端没有路由，路由由后端负责，前端是切图仔
2. 前后端分离，前端有独立的（html5）路由，实现页面切换

- 不管什么路由模式，取别名，as Router 可读性好

- 页面组件的懒加载
为了性能，快，在需要的时候才加载，而不是一上来就加载所有页面组件，可以延迟其他页面的加载

### 路由模式

React Router 中两种最常见的路由模式。它们的功能是一样的（实现页面跳转不刷新），但底层原理和对服务器的要求完全不同。

简单的一句话总结：

* BrowserRouter：好看、标准、现代化，但需要服务器配合。是基于 HTML5 的 **History API** (pushState, replaceState) 来实现的，即页面不刷新。
* HashRouter：URL 带个 `#` 号，略丑，但不需要服务器配置（即插即用）。 

如果你在本地开发 (localhost:3000) 觉得两个都一样，是因为 React 的脚手架工具（Vite/Webpack）内置的开发服务器已经帮你自动处理好了 BrowserRouter 的重定向问题。一旦打包部署上线，区别就出来了。

- 默认首选： BrowserRouter。它是现代 Web 应用的标准。

- 特殊情况选 HashRouter：

1. 你把项目部署在 GitHub Pages 上（GitHub Pages 对 SPA 的 History 模式支持很麻烦，用 Hash 最省事）。
2. 你只是要把打包出的 dist 文件夹扔给后台，后台人员告诉你“我不会配置 Nginx，你就给我个能点的 HTML 文件”。
3. 你的应用是一个完全不需要联网的本地文件系统应用（比如 Electron 包裹的本地网页）。

所谓 History API 路由，本质上是一场精心策划的“骗局”：

1. 你点链接： React 阻止了浏览器的默认跳转，用 pushState 假装跳了过去（改了 URL）。
2. 你点后退： React 监听 popstate，假装回退了（手动换组件）。
3. 你点刷新： 骗局穿帮了！ 浏览器真的拿着这个假 URL 去问服务器，服务器如果没有配置好（也就是之前说的配置），就会一脸懵逼：“我没有这个文件啊”，然后报 404。

这就是为什么 BrowserRouter 需要服务器配置，因为它在客户端“伪造”了路径。

### 路由有多少种？

- 普通路由
- 动态路由 :id
- 通配路由 *
- 嵌套路由 Outlet
- 路由守卫 ProtectRoute
- 重定向路由 Redirect Navigate

### 路由生成访问历史

history 对象，栈结构，每次路由切换，就会在栈中添加一个记录，记录了路由的路径和参数，当点击后退按钮时，就会从栈中弹出一个记录，然后根据记录中的路径和参数，渲染对应的组件。
<Navigate replace to='/new-path' />，replace属性， 是 redirect 跳转时，替换当前历史记录，不会添加新记录，new-path 替换 old-path

### 单页应用（SPA）
- 传统的开发是多页的，基于 http 请求，每次 url 发生改变后，去服务器重新请求整个页面。
  体验不好，页面会白一下
- 单页应用（SPA） react-router-dom html5 history api 实现的
  前端路由
  路由改变后
  前端会收到一个事件，将匹配的新路由显示在页面上


## typescript

Javascript 是动态类型语言，类型检查是在运行时进行的，而 typescript 是静态类型语言，类型检查是在编译时进行的。
ts 是 js 的超集，强类型静态语言

- 安装 ts
  npm install -g typescript
- 编译 ts 文件 -> js 文件
  tsc 2.ts
- 运行 js 文件
  node 2.js 
- 监听 ts 文件变化，自动编译
  tsc --watch 2.ts
- ts 的优点
  - 静态类型
  - 边写边检测bug
  - 编译时检查类型错误
  - 代码建议、文档查看都非常方便
  - 没有使用变量等垃圾代码提示未使用（console.log()）
    重构、修改别人的代码
    干净的代码

1. ts 的数据类型 4.ts

### typescript 实战 todos

## zustand 状态管理库

如果说国家需要有中央银行，那么前端项目就需要中央状态管理系统。zustand \ redux 都是前端状态管理库，但是 zustand 更轻量，更简单，更易用。
- 组件 = UI + State
- store 将状态存到 store 仓库中管理
  全局共享
- 基于hooks思想实现的

## 数据库设计

- 关系型数据库 mysql\postgresql
是一种以二维表格（行/列），组织存储结构，通过主键（Primary key）和外键（Foreign key）实现表格间的逻辑关联，遵循 ACID 事务特性，确保数据的一致性和完整性。
表 Table users 类
row 实例
column 属性

### 主键 primary key
- 词典
  索引目录
- 唯一的，自增的
- 高效的，利用索引

### 唯一索引 unique 约束
- username 唯一索引，唯一性，正确性

### 外键 foreign key 约束
- posts 文章 id，userId 外键，引用 users 表的主键 id
  posts.userId == users.userId

### 普通外键 Key
- 不能乱建
- 查询的频繁度高，建立索引

### 文章系统
- 文章表 posts
- 用户表 users
- 评论表 comments
- 点赞表 likes
- 标签表 tags
- 收藏表 favorites

### 连接
- 左连接
  左表（posts）的所有记录，右表（comments）符合条件的记录
- 右连接
  右表（comments）的所有记录，左表（posts）符合条件的记录
- 内连接
  左表（posts）和右表（comments）都符合条件的记录

### ACID

1. Atomicity（原子性）
- 事务是一个不可分割的操作单元：要么全部成功执行，要么全部不执行（回滚）。
- 举例：银行转账中，从 A 账户扣款和向 B 账户加款必须同时成功或同时失败，不能只完成其中一步。
  
1. Consistency（一致性）
- 事务执行前后，数据库必须从一个合法状态转换到另一个合法状态，遵守所有预定义的约束（如主键、外键、唯一性、检查约束等）。
- 注意：一致性依赖于原子性、隔离性和持久性共同保障，并非单独实现。
  
1. Isolation（隔离性） 
- 多个并发事务之间互不干扰。即使多个事务同时执行，每个事务看到的数据状态应如同串行执行一样。
- 数据库通过隔离级别（如读未提交、读已提交、可重复读、串行化）来控制并发行为，防止脏读、不可重复读、幻读等问题。
  
1. Durability（持久性）
- 一旦事务提交成功，其对数据的修改就是永久性的，即使系统崩溃（如断电、宕机），数据也不会丢失。
- 通常通过写入日志（如 redo log、WAL）来保证。

### psql
#### 基本操作
\list 列出所有数据库
创建数据库
create database xuebi with owner=postgres encoding='utf8';
进入数据库
\connect xuebi 或 \c xuebi

#### prompt 建表

```
你是一位psql高级工程师，需要设计一个users表，
包含id, name, password 三个字段，id 自增，主键；name 不能重复；password 不能为空。
请给出建表sql
```

CREATE TABLE users (
    -- 使用 BIGINT 避免未来数据量过大导致 ID 溢出，IDENTITY 是 SQL 标准自增方式
    -- INT（上限21亿） BIGINT（8字节）
    id BIGINT GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
    
    -- UNIQUE 约束会自动创建索引，NOT NULL 保证数据完整性
    name VARCHAR(255) NOT NULL UNIQUE,
    
    -- 密码字段，通常长度设为 255 以适配各种哈希加密算法（如 bcrypt）
    password VARCHAR(255) NOT NULL,
    
    -- 高级工程师通常会增加这两个审计字段
    created_at TIMESTAMPTZ DEFAULT CURRENT_TIMESTAMP,
    updated_at TIMESTAMPTZ DEFAULT CURRENT_TIMESTAMP
);

#### seeds 初始化数据

```
  INSERT INTO "users" ("id", "name", "password") VALUES
  ('1', '王皓', '$2b$10$CsO/ykedPpuxqUETBZTYm.F2U4TXDdo01rLmoRPwjKBv3pIL5pnWq'),
  ('2', '小雪', '$2b$10$CsO/ykedPpuxqUETBZTYm.F2U4TXDdo01rLmoRPwjKBv3pIL5pnWq'),
  ('3', '李白', '$2b$10$CsO/ykedPpuxqUETBZTYm.F2U4TXDdo01rLmoRPwjKBv3pIL5pnWq'),
  ('4', '杜甫', '$2b$10$CsO/ykedPpuxqUETBZTYm.F2U4TXDdo01rLmoRPwjKBv3pIL5pnWq'),
  ('5', '白居易', '$2b$10$CsO/ykedPpuxqUETBZTYm.F2U4TXDdo01rLmoRPwjKBv3pIL5pnWq'),
  ('6', '张三', '$2b$10$CsO/ykedPpuxqUETBZTYm.F2U4TXDdo01rLmoRPwjKBv3pIL5pnWq');
```

- prompt 升级
 你是一位psql 高级工程师， 需要建一个posts 表， 包含id, title, content,userId 三个字段。id 自增， 主键， title 不为空，不超过255个字符， content  长文本，  usersId 是bigint 类型，是 users 表的外键，请给出建表sql

CREATE TABLE posts (
    id BIGINT GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
    title VARCHAR(255) NOT NULL,
    content TEXT,
    "userId" BigInt NOT NULL,
    created_at TIMESTAMPTZ DEFAULT CURRENT_TIMESTAMP,
    updated_at TIMESTAMPTZ DEFAULT CURRENT_TIMESTAMP,
    CONSTRAINT fk_posts_user FOREIGN KEY ("userId") REFERENCES users(id) ON DELETE CASCADE
);

INSERT INTO "posts" ("title", "content", "userId") VALUES 
('黄鹤楼送孟浩然之广陵', '故人西辞黄鹤楼，烟花三月下扬州', 3),
('春夜喜雨', '好雨知时节，当春乃发生', 4),
('琵琶行', '浔阳江头夜送客，枫叶荻花秋瑟瑟', 5),
('静夜思', '床前明月光，疑是地上霜', 3),
('望岳', '会当凌绝顶，一览众山小', 4),
('浪淘沙', '白浪茫茫与海连，平沙浩浩四无边', 5),
('将进酒', '君不见黄河之水天上来，奔流到海不复回', 3),
('天末怀李白', '凉风起天末，君子意如何', 4),
('花非花', '花非花，雾非雾，夜半来，天明去', 5),
('望庐山瀑布', '日照香炉生紫烟，遥看瀑布挂前川', 3),
('绝句二首', '迟日江山丽，春风花草香', 4),
('秋思', '夕照红于烧，晴空碧胜蓝', 5),
('早发白帝城', '朝辞白帝彩云间，千里江陵一日还', 3),
('龙门镇', '细泉兼轻冰，沮洳栈道湿', 4),
('采莲曲', '菱叶萦波荷飐风，荷花深处小船通', 5),
('独坐敬亭山', '众鸟高飞尽，孤云独去闲', 3),
('三绝句', '楸树馨香倚钓矶，斩新花蕊未应飞', 4),
('江南春', '青门柳枝软无力，东风吹作黄金色', 5),
('白云泉', '天平山上白云泉，云自无心水自闲', 5),
('叶子的肖像', '叶子的肖像，每张都不一样', 1),
('月下独酌', '花间一壶酒，独酌无相亲', 3),
('登楼', '花近高楼伤客心，万方多难此登临', 4),
('大明湖的荷花', '大明湖里没青蛙，大明湖里有荷花', 1),
('关山月', '明月出天山，苍茫云海间', 3);


## nestjs
express 极简框架
nestjs 企业级开发，基于 typescript，采用模块化架构和依赖注入，
旨在构建高效、可扩展且易于维护的企业级后端应用

- **npm i -g @nestjs/cli**
- **nest --version**
- 新建项目 
  **nest new nest-test-demo**
- **pnpm run start:dev**

### nestjs 理解
- 工厂模式
- main.ts 入口文件
- Moudle
  app.module.ts 根模块，引导应用的启动

### http 请求动作
在 RESTful API 设计中，不同的动作对应不同的语义，一切皆资源
- GET —— 获取数据
- POST —— 创建数据
- PUT —— 完整更新数据
- PATCH —— 部分更新数据
- DELETE —— 删除数据

- **pnpm i pg**

## notes AI 全栈项目

- 登录功能

- 文章系统

- AIGC 功能
  
- nestjs 后端

### UI组件库 shadcn

- 页面由组件构成，选用第三方组件库

- shadcn 组件严格按需加载

- shadcn 组件可以下载到本地，可以随意的修改

- shadcn 基于 tailwindcss 实现组件的样式

- 配置 alias 设置路径别名，更短，好用


流程：

    - pnpm i shadcn@latest

    - 配置tailwindcss

    - 在 vite.config.ts 中配置 alias 设置路径别名，在 tsconfig.json 中配置 paths 路径别名，在 tsconfig.app.json 中继承 tsconfig.json
      - pnpm i -D @types/node 是为了在 ts 中使用 node 的内置模块 path

    - npx shadcn@latest init

    - npx shadcn@latest add button

    - npx shadcn@latest add card

npx 是 Node.js 自带的工具，用于临时安装并**执行** npm 包中的命令，无需全局或本地预先安装。

不用预先安装，试用，测试开发人员用，用完会删除

- shadcn 提供命令行工具

  - npx shadcn@latest add 组件名

 如果需要一个 button 组件
 npx shadcn@latest add button

### vite 的配置

- vite.config.ts 配置对象

  - plugins 插件数组
    - react | vue
    - tailwindcss
  
  - resolve 解析配置对象
    - alias 路径别名对象
      - @ -> __dirname/src
      - npm i -D @types/node，node 来到 ts 开发的时候，需要单独安装 node 的类型声明文件，js 不需要
  
### ts 的配置

根目录下的 tsconfig.json 配置对象

tsconfig.json           # 基础配置（根配置）
├── tsconfig.app.json   # 应用配置
├── tsconfig.node.json  # Node.js/构建工具配置
└── tsconfig.test.json  # 测试配置（可选）

配置文件	                  用途	                典型配置差异
tsconfig.json	            基础共享配置	          通用编译器选项
tsconfig.app.json	        前端应用	             "module": "esnext", "jsx": "react-jsx"
tsconfig.node.json	      构建工具/后端	          "module": "commonjs", 包含 Node.js 类型

- compilerOptions 编译选项对象
  - baseUrl 基础路径
    - . 表示项目根目录
  - paths 路径别名对象
    - @/* 指向 src/*


### 路由

- pnpm i react-router-dom
- 路由懒加载（性能优化的关键）
- suspense + lazy 实现路由懒加载
- 自定义loading组件
- 路由守卫

### 状态管理
pnpm i zustand
- 状态管理库
- 全局状态管理
- 全局状态管理的实现原理
- 全局状态管理的使用场景

### BackToTop 组件

- 通用组件
- 自有状态isVisible
- onScroll 判断一个阙值
- scroll事件频繁触发，性能优化
    节流，放在utils目录下，是一个工具函数
- 组件卸载时，移除scroll事件监听，防止内存泄漏

### 幻灯片组件 slides

- shadcn 提供了 Carousel、CarouselContent、CarouselItem 组件
- 一组组件，层次结构如下
    - Carousel 组件
        - CarouselContent 组件
            - CarouselItem 组件
- 自动播放的功能作为插件引入， shadcn 简单性能好，定制性更好
    useRef 持久化可变的对象
    plugins=[]
- api 向外暴露 Carousel 的各种功能
  selectedIndex 私有状态
  api onSelect 方法 改变它
- 指示点
    循环输出
    动态类名
- css
  - transition-all
  - gradient 线性渐变，取代图片（渐变色）做背景
    性能优化 图片做背景 http下载的开销 减少http并发数

### store

- user 全局共享
- 每个页面级别组件都有自己独立的store
- 组件 UI 和 数据分离

### Post List

- 数据怎么提供呢？
  - 真实数据在后端
  - axios 请求后端api
  - 前端要等待后端接口吗？不能等，前后端分离的基础上，前端可以自行解决数据需求？ mock 一下，伪造请求
  api接口文档
  GET /api/posts?page=1&limit=10 返回内容
  {
    status: 200,
    list: Post[]
  }
  只要切换后端真正的地址，无缝对接

### mockjs

- 前端接口伪造，开发时候用，上线前切换为后端接口，无缝对接
- **pnpm i vite-plugin-mock -D** 用来在开发环境下，伪造接口，返回模拟数据
- 配置 vite.config.ts
  - 引入 mock 插件
  - plugins 数组 加入 mock 插件
  - 配置 mock 插件的选项
    - mockPath 指向 mock 目录
    - localEnabled 开发环境下开启 mock 接口
    - prodEnabled 生产环境下关闭 mock 接口
- vite 启动 mock
- 前后端确立接口开发文档
- **pnpm i mockjs** 用来随机生成数据
- mockjs 语法
- mockPath 新建posts.js
  export default {
    {
      url:,
      method:,
      response:(req, res) => {}
    }
  }
- mockjs 随机功能 @
- 分页机制
  - Page, limit parseInt
  - 计算 start, end
  - 分页数据 paginatedData
  - slice 截取数组
  - 返回分页数据
- **pnpm i axios**

### JWT 登录

- JWT 的工作流程（以登录为例）
1. 用户提交用户名/密码到服务器。
2. 服务器验证成功后，生成一个 JWT（含用户 ID、角色、过期时间等），用密钥签名。
3. 服务器将 JWT 返回给客户端（通常放在响应体或 Authorization: Bearer <token> 头中）。
4. 客户端存储 JWT（如 localStorage、cookie）。
5. 后续请求，客户端在 Authorization 头中携带 JWT：
```js
Authorization: Bearer eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.xxxxx
```
6. 服务器收到后：
- 验证签名是否合法（防伪造）
- 检查 exp 是否过期
- 提取 payload 中的用户信息，无需查数据库（无状态）

- htttp 无状态的
Cookie Authorization token 身份令牌
- 颁发令牌 token
- 安装 jwt 库
  **pnpm i jsonwebtoken**
  json 用户身份对象 web 形式 token 令牌
  用户名+密码 { id:1, name:'admin' } json 加密成一个token
  请求时，再传来，服务器端 decode 得到用户对象

  - sign 方法 由服务器调用，服务器将用户对象，secret, 过期时间 加密成一个 token
  - verify 方法 由服务器调用，服务器将 token, secret 解密成用户对象
  - decode方法，解析请求头，Authorization 头中的 token，服务器拿到用户对象


## api 后端接口项目

- npm install -g @nestjs/cli 全局安装 NestJS 命令行工具
- nest new posts 新建项目
- cd posts
- pnpm i
- pnpm run start:dev

高度模块化，依赖注入特性的企业级开发框架

- 数据库

### prisma ORM

将数据库映射成对象
Table -> 类
row -> 实例
props -> props
psql/mysql sql太专业了，prisma 翻译官
后端 -> prisma -> sql
User(service class) === User(table)
create === Insert
findMany === Select 

### ORM ObjectRelationMapping 对象关系映射

- pnpm i prisma

- pnpm uninstall prisma

- **pnpm i prisma@6.19.2 -D**

- **pnpm i @prisma/client@6.19.2**

### Prisma 的初始化流程

- 建数据库
- prisma 命令行 + @prisma/client  ->  (ORM)
- npx prisma init


### schema 文件

数据库是最重要的，schema 就是数据库的设计稿，让设计稿像文件一样保留了下来
用model模型类的概念，来描述数据表
@id     primary key
@default(@autoincrement())
@db.VarChar(255)
@unique

### migrate 数据表的迁移

- npx prisma migrate dev --name init_user -> npx prisma migrate dev --name add_posts

- 每个迁移文件，都要描述清楚，做了什么改变
- 建议命名规范
init_user
add_email_field
add_post_table
add_index_to_user

- 方便
- 留下日志

- npx prisma generate

### seeds 数据填充

- 启动 Prisma 可视化数据库管理工具
**npx prisma studio**

- 安装 NestJS 的 Express 平台适配器
**pnpm i @nestjs/platform-express**
NestJS = 框架逻辑
Express = 实际处理 HTTP 请求的服务器
@nestjs/platform-express = 连接两者的桥梁

### DTO Data Transfer Object 数据传输对象

从前端 -> 后端 -> 控制器 -> service transfer 过程
- dto/post-query.dto.ts
- dto/post-new.dto.ts
- class-validator 验证器
- class-transformer 转换器
  **pnpm i class-validator class-transformer**
  验证器，用来验证前端传来的数据是否符合要求
  转换器，用来将前端传来的数据，转换为我们需要的类型
将参数的校验，流程化，规范化

- 全局配置
app.useGlobalPipes(new ValidationPipe({
  whitelist: true,  
  forbidNonWhitelisted: true, 
  transform: true,  
}))

### @prisma/client

- 怎么给 service 提供 client，代替db

- 文章列表
  - 背后有多条 sql
  - count posts 用于分页 total
  - 文章列表详情
    title content....
    - 拿到每篇文章的id   tags
    - likes 点赞数

- dto 
  用户提交（query?, body）打理的标准
- main.js 启用中间件
  约束：多传的不要，少传的要报错，transform 转换类型
  class-validator 验证器 属性类型约束的装饰类
  class-transformer 转换器 类型转换
  约束 query | body

### prisma 流程
- prisma 命令行、@prisma/client @6.19.2
- npx prisma init
  prisma 文件夹，schema 文件
  .env 描述 psql 连接的字符串
- schema 编写 Model （属性、类型、key、关系）
- npx prisma migrate dev --name init_user
- npx prisma generate 生成 client 需要的内容 -> generated 文件夹
- prisma module
  - 和 nest 融合 
  - @Global exports
- 提供 prisma service
  - 注入 prisma client
  - 提供数据库操作方法
- prisma service 注入到 posts service

## 图片懒加载
- img src http 请求，并发
  - 需要加载的图片 首页首屏
  图片用占位图片（小），优先去加载html,css,首屏的显示速度优先
  - 视图窗口（viewport）之外的图片，不需要加载，等用户滚动到可见区域，再加载
    onscroll 事件 节流 滚动哪里懒加载进入视窗的图片
  - 首先实例化 IntersectionObserver 观察者
  - 观察每个图片
  - 图片进入视窗，加载图片，停止观察
    entries 所有被观察的元素
    entry 每个被观察的元素
    entry.isIntersecting
    entry.target
    dataset.src 替换 src
    observer.unobserve 取消观察
    给所有的.lazy 加观察 observer.observe

## 静态服务器
- service，提供数据，动态
- 静态资源，html/css/js/img
- 根目录下的uploads 文件夹，用来存储上传的图片
- main.ts 配置静态服务器
  - 第一个参数，静态资源目录 
  - 第二个参数，配置对象
    - prefix 访问路径前缀
  区别于动态资源，不需要controller 提供路由
  只需要配置一下
  - app.useStaticAssets 这是 NestJS 提供的方法，用于配置静态资源托管。
    所谓的“静态资源”是指图片、PDF、视频、CSS 或 JS 文件等不需要后端逻辑处理、直接返回给客户端的文件。
  - join(process.cwd(), 'uploads') 这部分定义了文件在硬盘上的实际位置：
    在 Node.js 环境中，join 方法来源于内置的 path 模块。
      process.cwd()：获取当前项目的根目录路径。
      'uploads'：项目根目录下名为 uploads 的文件夹。
      合起来的意思：告诉程序，去根目录下的 uploads 文件夹里找文件。
  - prefix: '/uploads' 这部分定义了访问路径的前缀（虚拟路径）：
      '/uploads'：当客户端请求 /uploads 开头的路径时，NestJS 会去 uploads 文件夹里找对应的文件。

### 接口数据格式调整
- 依据前后端文档格式要求
- prisma-client 查出数据之后，通过map格式化输出
- 后端对接口文档的尊重

### 图片懒加载
- 列表一定要做图片的懒加载
- react-lazyload 提供了组件 LazyLoad
  - 安装 pnpm i react-lazyload
  - 安装 prop-types， pnpm add prop-types
  - 引入 import LazyLoad from 'react-lazyload'
  - 使用
    <LazyLoad>
      <img loading="lazy" src={post.thumbnail} className="w-full h-full object-cover" />
    </LazyLoad>
  - 包着要显示的图片 loading="lazy"

## InfiniteScroll 组件
- 通用组件
  为列表带来分页无限加载的能力
- 抽象封装能力
  可定制的列表作为children
  在children 下面添加一个哨兵节点
- 使用IntersectionObserver threshold 0.0
- loadMore loading hasMore 一起放在store中，联结起来
- 联动启动

## 首页优化
- 反复切换 首页，其他页面，重复加载
- 路由的切换，单页应用 SPA Single Page Application
  React + React-Router
  快 不会白屏
  没有前端路由，/  ->  /post/:id ，服务器 后端路由 http 请求 返回完整的html，所以白屏
  前端负责路由，js 中拿出对应的组件，进行组件卸载，替换
- 首页太重要了，用户频繁的在首页和其他页面切换
  首页的不断卸载挂载，重复渲染，不违和

### KeepAlive 组件
- home 不能卸载，keep alive
- react-activation
  cache 缓存 home, 界面和数据保持
  display: none 离开文档流

- **pnpm i react-activation**
- KeepAlive + AliveScope  saveScrollPosition="screen" + 在应用入口处包裹 AliveScope

## 登录功能
- 注册 backend/posts/src/user
  - password 单向加密存储，单向是指不能解密，防程序员，黑客， 可以确保密码安全
  - bcrypt 加密存储密码
    注册时，对密码进行加密，存储到数据库
    登录时，对密码进行加密，和数据库中的密码进行比较
    bcrypt 是一个用于安全哈希和验证密码的加密库，具有加盐和自适应计算强度的特点，能有效抵御彩虹表和暴力破解攻击。
    是单向加密，更准确的说是**单向哈希**，它将密码通过哈希算法（结合随机加盐）装换成一个固定长度的字符串，无法从生成的哈希值反推出原始密码
    **pnpm i bcrypt**

- 由于之前插入了假数据，导致我们创建用户插入数据表时，会发生id 冲突，因为默认从1开始创建，但插入的假数据里已经有1了，我们只需要在psql中执行这条命令
- SELECT setval('users_id_seq', (SELECT COALESCE(MAX(id), 0) FROM users));

- 登录
  cookie 之前的登录解决方案，http 自动带上cookie
  cookie 比 localStorage 更小的本地存储，只能存储字符串，存身份信息
  JWT Authorization 字段 axios 请求拦截器加上token
  轻量级，跨域共享 JSON（用户对象信息 不安全）Web Token(hash 令牌)
  双向加密，服务端加密，客户端解密
  身份验证
- Auth 鉴权模块
  - @nestjs/jwt 需要安装的，但是是 nestjs 本身提供的 jwt 身份验证模块
    jwt 协议
  - JwtService sign
  - JwtModule Auth模块里需要 import 它，方便注入依赖

### JWT 双token 机制

- mockjs，使用了jsonwebtoken，单 token sign/verify
- 单token 容易被中间人截获，不安全，双token 机制
- access_token（有效期短，以分钟为单位） 和 refresh_token（有效期长，以天为单位） 
  一样具有token 验证的能力（都是 JwtService.signAsync）
  axios 请求拦截中，在每次请求前，判断 access_token 是否过期
  如果过期，使用 refresh_token 去请求新的 access_token 和 refresh_token
  如果 refresh_token 也过期，提示用户重新登录
- Promise.all 
  举个例子 nest.js posts 列表查询，count 和 list， Promise.all 并发查询
  还有 nest.js 双 token 的并行请求 access_token 和 refresh_token

## 错误异常处理模块
@nestjs/common
- 后端，错误处理是核心模块。
  4XX, 400 BadRequest 401 UnAuthorizated
  5XX, 服务器端错误
- try {} catch() {...}
  catch 错误是可以被处理的
- BadRequestException
  nestjs 准备了各种异常 
  各种异常处理类，解决各种问题
  - return
  - 400|401|403|500... statusCode message

## 鉴权处理
- 新增文章，点赞等，需要权限操作，需要先登录
- access_token, refresh_token 双 token 机制
  api 请求由 axios 自动带上access_token, 在 Authorization
- backend posts.controller createPost 方法
  createPost 需要受到鉴权的保护？ nestjs 提供了 guard 机制
  req Authorization access_token
  拿到 user ? @nestjs/jwt verifyAsync

  新增文章，需要先登录，才能发布
  从 Authorization 中提取 access_token
  验证 access_token 是否过期
  如果过期，使用 refresh_token 去请求新的 access_token 和 refresh_token
  如果 refresh_token 也过期，提示用户重新登录
  如果 access_token 验证通过，新增文章

### nestjs useGuard 鉴权保护
UseGuards 是一个装饰器，用于在控制器或路由处理方法上应用守卫
会在路由处理方法前，先执行Guard函数，鉴权
如果鉴权失败，返回 401，直接退出
如果成功，用 jwt verify 出来的对象帮我们添加到 req 对象上
路由处理方法就可以使用 user 信息

- **pnpm i @nestjs/passport**
- AuthGuard 是 NestJS 里用 Passport 做认证的一个现成“守门员”。
  你只要在接口上加个 @UseGuards(AuthGuard('jwt'))，它就会自动检查请求头里的 Token 是否合法，没登录或 Token 无效就直接拦住，不用自己写验证逻辑，省事又安全
- AuthGuard('jwt') 是由@nestjs/passport 直接提供
- 报错 Unknow authentication strategy "jwt"
  jwt 鉴权策略在哪里？
  会去查找 @nestjs/passport 策略文档
- PassportStrategy 是 NestJS 提供的一个基类，用于将 Passport.js 的各种认证策略（如 JWT、本地登录等）封装成可被 Nest 注入和使用的策略服务。
- **pnpm i passport-jwt**
- jwt 双 token 流程
  - 双 token 生成 @nestj/jwt
  - 鉴权 @nestjs/guard UseGuard
  - 刷新？ refresh
    post /posts 新增 token
    UseGuard 返回401 ?