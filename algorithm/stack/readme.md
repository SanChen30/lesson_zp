# stack

1. 栈是什么
    栈是一种后进先出（LIFO）的线性数据结构。

2. 栈的ADT
    栈的抽象数据类型（ADT）定义了栈的操作和行为。
    
    栈的ADT包括以下操作：
    - push：将元素压入栈顶。
    - pop：从栈顶弹出元素。
    - peek：获取栈顶元素，不弹出。
    - isEmpty：检查栈是否为空。
    - size：获取栈的元素数量。

## get set

调用 getter/setter 时不需要加括号，就像访问普通属性一样。

1. 命名一致性

getter 和 setter 必须同名（比如都叫 value），否则会报错或行为不符合预期。

2. 不能与普通属性重名

如果你在构造函数中直接写 this.value = xxx，又定义了 get value()，就会造成无限递归（因为 this.value = xxx 会触发 setter，而 setter 又可能访问 this.value）。 正确做法：内部使用 _value 或其他名称存储实际值。

3. 只定义 getter 或 setter 是允许的
只有 getter：该属性是只读的。
只有 setter：该属性只能被赋值，不能读取（不常见）


## ES6 class 新特性

1. class 类抽象，属性和方法的模板

2. # 私有属性，保护了类的安全，封装了类的实现细节。

3. constructor 构造函数，用于创建和初始化对象。

4. 共享的方法

5. ES6 中 get 和 set 用于定义对象属性的访问器，实现对属性读取和赋值的拦截和控制

不想添加一个属性但又要提供

## 数组和链表实现栈的优缺点

1. 时间效率

数组：

入栈和出栈操作都在预先分配好的连续内存中进行，效率高，O(1)

如果入栈时超出数组容量，会触发扩容机制，导致入栈操作时间复杂度为O(n)

因为扩容需要复制所有的元素到新的数组中，事件复杂度为O(n)

链表：

虽然在入栈的时候开销大一些（ListNode实例化），但扩容非常灵活，O(1)

- 基于数组实现的栈在触发扩容时效率会降低到O(n)，但由于扩容时低频操作，因此平均效率高。
- 基于链表实现的栈，可以实现更加稳定的效率表现

2. 空间效率

- 基于数组的栈可能造成一定的空间浪费，由于链表节点需要额外的空间来存储指针，因此链表节点占用的空间相对较大。
